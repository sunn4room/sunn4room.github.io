<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 学习笔记 | sunn4room</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.62005803.css" as="style"><link rel="preload" href="/assets/js/app.2d05b873.js" as="script"><link rel="preload" href="/assets/js/9.fd2d7f08.js" as="script"><link rel="preload" href="/assets/js/3.5fc63a44.js" as="script"><link rel="preload" href="/assets/js/11.afdccb1f.js" as="script"><link rel="prefetch" href="/assets/js/10.50ae4a69.js"><link rel="prefetch" href="/assets/js/12.0010c894.js"><link rel="prefetch" href="/assets/js/13.eb55877c.js"><link rel="prefetch" href="/assets/js/14.65cfc2ff.js"><link rel="prefetch" href="/assets/js/15.0b8b74f4.js"><link rel="prefetch" href="/assets/js/16.4dbb4aa4.js"><link rel="prefetch" href="/assets/js/17.271c05bb.js"><link rel="prefetch" href="/assets/js/18.4c3e94d0.js"><link rel="prefetch" href="/assets/js/19.1a0cddca.js"><link rel="prefetch" href="/assets/js/2.d45a9055.js"><link rel="prefetch" href="/assets/js/20.cdf7cb28.js"><link rel="prefetch" href="/assets/js/21.fbf2cd3f.js"><link rel="prefetch" href="/assets/js/22.42257d5f.js"><link rel="prefetch" href="/assets/js/23.e26a383f.js"><link rel="prefetch" href="/assets/js/24.d9c833cd.js"><link rel="prefetch" href="/assets/js/25.f8ca341b.js"><link rel="prefetch" href="/assets/js/26.a42edc25.js"><link rel="prefetch" href="/assets/js/27.0127ab0c.js"><link rel="prefetch" href="/assets/js/28.cd79c0d4.js"><link rel="prefetch" href="/assets/js/29.c3f37782.js"><link rel="prefetch" href="/assets/js/30.043d284c.js"><link rel="prefetch" href="/assets/js/31.423ed3ce.js"><link rel="prefetch" href="/assets/js/32.26519eb1.js"><link rel="prefetch" href="/assets/js/33.f57167ad.js"><link rel="prefetch" href="/assets/js/34.ecaa6ee5.js"><link rel="prefetch" href="/assets/js/35.47e91ee0.js"><link rel="prefetch" href="/assets/js/36.258a624f.js"><link rel="prefetch" href="/assets/js/37.68bb6fda.js"><link rel="prefetch" href="/assets/js/38.94239711.js"><link rel="prefetch" href="/assets/js/39.e83c38cf.js"><link rel="prefetch" href="/assets/js/4.caf2fcbd.js"><link rel="prefetch" href="/assets/js/40.acf21eb1.js"><link rel="prefetch" href="/assets/js/41.d164530a.js"><link rel="prefetch" href="/assets/js/5.886701df.js"><link rel="prefetch" href="/assets/js/6.61d8e906.js"><link rel="prefetch" href="/assets/js/7.177acf7a.js"><link rel="prefetch" href="/assets/js/8.84396220.js">
    <link rel="stylesheet" href="/assets/css/0.styles.62005803.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="app"><div id="header"><img id="hero" src="/assets/img/hero.470debc7.png"><span id="title">Java 学习笔记</span><div id="search-box" class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div><aside id="aside"><div class="__vuescroll" style="height:100%;width:100%;padding:0;position:relative;overflow:hidden;"><div class="__panel __hidebar" style="position:relative;box-sizing:border-box;height:100%;overflow-y:hidden;overflow-x:hidden;transform-origin:;transform:;"><div class="__view" style="position:relative;box-sizing:border-box;min-width:100%;min-height:100%;"><div class="margin-box"><div class="white-line"></div><div class="shell"><div class="sh-header"><div class="dot" style="background-color: #e9524a"></div><div class="dot" style="background-color: #f1ae1b"></div><div class="dot" style="background-color: #59c837"></div></div><div class="sh-body"><div class="line"><span>&gt; </span><span style="color:#4ebdcf">Who are you?</span></div><div class="line right"><span style="color:#97d209">I'm sunn4room</span><span> &lt;</span></div><div class="line right"><span style="color:#97d209">em... Just Sunny Room</span><span> &lt;</span></div><div class="line right"><span style="color:#97d209">And you?</span><span class="cursor">a</span><span> &lt;</span></div></div></div><div class="header-tag" style="font-size:1rem;font-weight:bold;margin-top:1.5rem;">Java 学习笔记</div><a href="#注释" class="header-tag" style="font-size:1rem;margin-left:1rem;">注释</a><a href="#标识符" class="header-tag" style="font-size:1rem;margin-left:1rem;">标识符</a><a href="#类型系统" class="header-tag" style="font-size:1rem;margin-left:1rem;">类型系统</a><a href="#整型" class="header-tag" style="font-size:1rem;margin-left:2rem;">整型</a><a href="#字符型" class="header-tag" style="font-size:1rem;margin-left:2rem;">字符型</a><a href="#浮点型" class="header-tag" style="font-size:1rem;margin-left:2rem;">浮点型</a><a href="#布尔型" class="header-tag" style="font-size:1rem;margin-left:2rem;">布尔型</a><a href="#数组" class="header-tag" style="font-size:1rem;margin-left:2rem;">数组</a><a href="#类与接口" class="header-tag" style="font-size:1rem;margin-left:2rem;">类与接口</a><a href="#运算符" class="header-tag" style="font-size:1rem;margin-left:1rem;">运算符</a><a href="#算术运算符" class="header-tag" style="font-size:1rem;margin-left:2rem;">算术运算符</a><a href="#位运算符" class="header-tag" style="font-size:1rem;margin-left:2rem;">位运算符</a><a href="#赋值运算符" class="header-tag" style="font-size:1rem;margin-left:2rem;">赋值运算符</a><a href="#比较运算符" class="header-tag" style="font-size:1rem;margin-left:2rem;">比较运算符</a><a href="#逻辑运算符" class="header-tag" style="font-size:1rem;margin-left:2rem;">逻辑运算符</a><a href="#条件运算符" class="header-tag" style="font-size:1rem;margin-left:2rem;">条件运算符</a><a href="#流控制" class="header-tag" style="font-size:1rem;margin-left:1rem;">流控制</a><a href="#选择结构" class="header-tag" style="font-size:1rem;margin-left:2rem;">选择结构</a><a href="#if" class="header-tag" style="font-size:1rem;margin-left:3rem;">if</a><a href="#switch" class="header-tag" style="font-size:1rem;margin-left:3rem;">switch</a><a href="#循环结构" class="header-tag" style="font-size:1rem;margin-left:2rem;">循环结构</a><a href="#for" class="header-tag" style="font-size:1rem;margin-left:3rem;">for</a><a href="#while" class="header-tag" style="font-size:1rem;margin-left:3rem;">while</a><a href="#类与对象" class="header-tag" style="font-size:1rem;margin-left:1rem;">类与对象</a><a href="#类定义" class="header-tag" style="font-size:1rem;margin-left:2rem;">类定义</a><a href="#包机制" class="header-tag" style="font-size:1rem;margin-left:3rem;">包机制</a><a href="#static" class="header-tag" style="font-size:1rem;margin-left:3rem;">static</a><a href="#变量成员" class="header-tag" style="font-size:1rem;margin-left:3rem;">变量成员</a><a href="#初始化块" class="header-tag" style="font-size:1rem;margin-left:3rem;">初始化块</a><a href="#构造器" class="header-tag" style="font-size:1rem;margin-left:3rem;">构造器</a><a href="#方法成员" class="header-tag" style="font-size:1rem;margin-left:3rem;">方法成员</a><a href="#注解" class="header-tag" style="font-size:1rem;margin-left:3rem;">注解</a><a href="#封装" class="header-tag" style="font-size:1rem;margin-left:2rem;">封装</a><a href="#继承" class="header-tag" style="font-size:1rem;margin-left:2rem;">继承</a><a href="#多态" class="header-tag" style="font-size:1rem;margin-left:2rem;">多态</a><a href="#抽象类" class="header-tag" style="font-size:1rem;margin-left:3rem;">抽象类</a><a href="#接口" class="header-tag" style="font-size:1rem;margin-left:3rem;">接口</a><a href="#内部类" class="header-tag" style="font-size:1rem;margin-left:2rem;">内部类</a><a href="#非静态内部类" class="header-tag" style="font-size:1rem;margin-left:3rem;">非静态内部类</a><a href="#静态内部类" class="header-tag" style="font-size:1rem;margin-left:3rem;">静态内部类</a><a href="#局部类对象" class="header-tag" style="font-size:1rem;margin-left:2rem;">局部类对象</a><a href="#匿名局部类对象" class="header-tag" style="font-size:1rem;margin-left:3rem;">匿名局部类对象</a><a href="#lambda-表达式对象" class="header-tag" style="font-size:1rem;margin-left:3rem;">Lambda 表达式对象</a><a href="#枚举类" class="header-tag" style="font-size:1rem;margin-left:2rem;">枚举类</a><a href="#类加载与对象实例化" class="header-tag" style="font-size:1rem;margin-left:2rem;">类加载与对象实例化</a><a href="#垃圾回收" class="header-tag" style="font-size:1rem;margin-left:2rem;">垃圾回收</a><a href="#泛型" class="header-tag" style="font-size:1rem;margin-left:1rem;">泛型</a><a href="#泛型类、接口" class="header-tag" style="font-size:1rem;margin-left:2rem;">泛型类、接口</a><a href="#泛型方法" class="header-tag" style="font-size:1rem;margin-left:2rem;">泛型方法</a><a href="#类型通配符" class="header-tag" style="font-size:1rem;margin-left:2rem;">类型通配符</a><a href="#原始类型" class="header-tag" style="font-size:1rem;margin-left:2rem;">原始类型</a><a href="#异常处理" class="header-tag" style="font-size:1rem;margin-left:1rem;">异常处理</a><a href="#异常处理机制" class="header-tag" style="font-size:1rem;margin-left:2rem;">异常处理机制</a><a href="#异常类" class="header-tag" style="font-size:1rem;margin-left:2rem;">异常类</a><a href="#命令行工具" class="header-tag" style="font-size:1rem;margin-left:1rem;">命令行工具</a><a href="#javac" class="header-tag" style="font-size:1rem;margin-left:2rem;">javac</a><a href="#jar" class="header-tag" style="font-size:1rem;margin-left:2rem;">jar</a><a href="#java" class="header-tag" style="font-size:1rem;margin-left:2rem;">java</a><a href="#javadoc" class="header-tag" style="font-size:1rem;margin-left:2rem;">javadoc</a><a href="#jps" class="header-tag" style="font-size:1rem;margin-left:2rem;">jps</a><a href="#jshell" class="header-tag" style="font-size:1rem;margin-left:2rem;">jshell</a><a href="#项目管理工具" class="header-tag" style="font-size:1rem;margin-left:1rem;">项目管理工具</a><a href="#maven" class="header-tag" style="font-size:1rem;margin-left:2rem;">maven</a><a href="#gradle" class="header-tag" style="font-size:1rem;margin-left:2rem;">gradle</a><a href="#核心类" class="header-tag" style="font-size:1rem;margin-left:1rem;">核心类</a><a href="#ojbect" class="header-tag" style="font-size:1rem;margin-left:2rem;">Ojbect</a><a href="#包装类" class="header-tag" style="font-size:1rem;margin-left:2rem;">包装类</a><a href="#string" class="header-tag" style="font-size:1rem;margin-left:2rem;">String</a><a href="#system" class="header-tag" style="font-size:1rem;margin-left:2rem;">System</a><a href="#runtime" class="header-tag" style="font-size:1rem;margin-left:2rem;">Runtime</a><a href="#集合类" class="header-tag" style="font-size:1rem;margin-left:1rem;">集合类</a><a href="#collection" class="header-tag" style="font-size:1rem;margin-left:2rem;">Collection</a><a href="#set" class="header-tag" style="font-size:1rem;margin-left:3rem;">Set</a><a href="#list" class="header-tag" style="font-size:1rem;margin-left:3rem;">List</a><a href="#queue" class="header-tag" style="font-size:1rem;margin-left:3rem;">Queue</a><a href="#map" class="header-tag" style="font-size:1rem;margin-left:2rem;">Map</a><a href="#i-o-类" class="header-tag" style="font-size:1rem;margin-left:1rem;">I/O 类</a><a href="#工具类" class="header-tag" style="font-size:1rem;margin-left:1rem;">工具类</a><a href="#arrays" class="header-tag" style="font-size:1rem;margin-left:2rem;">Arrays</a><a href="#collections" class="header-tag" style="font-size:1rem;margin-left:2rem;">Collections</a><a href="#网络编程" class="header-tag" style="font-size:1rem;margin-left:1rem;">网络编程</a><a href="#并发编程" class="header-tag" style="font-size:1rem;margin-left:1rem;">并发编程</a><a href="#多线程" class="header-tag" style="font-size:1rem;margin-left:2rem;">多线程</a><a href="#thread" class="header-tag" style="font-size:1rem;margin-left:3rem;">Thread</a><a href="#thread-state" class="header-tag" style="font-size:1rem;margin-left:4rem;">Thread.State</a><a href="#threadgroup" class="header-tag" style="font-size:1rem;margin-left:4rem;">ThreadGroup</a><a href="#thread-uncaughtexceptionhandler" class="header-tag" style="font-size:1rem;margin-left:4rem;">Thread.UncaughtExceptionHandler</a><a href="#threadlocal-t" class="header-tag" style="font-size:1rem;margin-left:4rem;">ThreadLocal\</a><a href="#runnable" class="header-tag" style="font-size:1rem;margin-left:4rem;">Runnable</a><a href="#callable-v" class="header-tag" style="font-size:1rem;margin-left:4rem;">Callable\</a><a href="#future-v" class="header-tag" style="font-size:1rem;margin-left:4rem;">Future\</a><a href="#runnablefuture-v" class="header-tag" style="font-size:1rem;margin-left:4rem;">RunnableFuture\</a><a href="#futuretask-v" class="header-tag" style="font-size:1rem;margin-left:4rem;">FutureTask\</a><a href="#executor" class="header-tag" style="font-size:1rem;margin-left:3rem;">Executor</a><a href="#executorservice" class="header-tag" style="font-size:1rem;margin-left:4rem;">ExecutorService</a><a href="#threadpoolexecutor" class="header-tag" style="font-size:1rem;margin-left:4rem;">ThreadPoolExecutor</a><a href="#forkjoinpool" class="header-tag" style="font-size:1rem;margin-left:4rem;">ForkJoinPool</a><a href="#scheduledexecutorservice" class="header-tag" style="font-size:1rem;margin-left:4rem;">ScheduledExecutorService</a><a href="#scheduledthreadpoolexecutor" class="header-tag" style="font-size:1rem;margin-left:4rem;">ScheduledThreadPoolExecutor</a><a href="#completionservice-v" class="header-tag" style="font-size:1rem;margin-left:3rem;">CompletionService\</a><a href="#executorcompletionservice-v" class="header-tag" style="font-size:1rem;margin-left:4rem;">ExecutorCompletionService\</a><a href="#completionstage-t" class="header-tag" style="font-size:1rem;margin-left:3rem;">CompletionStage\</a><a href="#completablefuture-t" class="header-tag" style="font-size:1rem;margin-left:4rem;">CompletableFuture\</a><a href="#线程同步" class="header-tag" style="font-size:1rem;margin-left:2rem;">线程同步</a><a href="#volatile" class="header-tag" style="font-size:1rem;margin-left:3rem;">volatile</a><a href="#synchronized" class="header-tag" style="font-size:1rem;margin-left:3rem;">synchronized</a><a href="#运行流程" class="header-tag" style="font-size:1rem;margin-left:4rem;">运行流程</a><a href="#cas" class="header-tag" style="font-size:1rem;margin-left:3rem;">CAS</a><a href="#varhandle" class="header-tag" style="font-size:1rem;margin-left:4rem;">VarHandle</a><a href="#atomic" class="header-tag" style="font-size:1rem;margin-left:4rem;">Atomic</a><a href="#aqs" class="header-tag" style="font-size:1rem;margin-left:3rem;">AQS</a><a href="#acquire-release-流程" class="header-tag" style="font-size:1rem;margin-left:4rem;">acquire - release 流程</a><a href="#acquireshared-releaseshared-流程" class="header-tag" style="font-size:1rem;margin-left:4rem;">acquireShared - releaseShared 流程</a><a href="#lock" class="header-tag" style="font-size:1rem;margin-left:3rem;">Lock</a><a href="#reentrantlock" class="header-tag" style="font-size:1rem;margin-left:4rem;">ReentrantLock</a><a href="#readwritelock" class="header-tag" style="font-size:1rem;margin-left:4rem;">ReadWriteLock</a><a href="#reentrantreadwritelock" class="header-tag" style="font-size:1rem;margin-left:4rem;">ReentrantReadWriteLock</a><a href="#condition" class="header-tag" style="font-size:1rem;margin-left:4rem;">Condition</a><a href="#locksupport" class="header-tag" style="font-size:1rem;margin-left:4rem;">LockSupport</a><a href="#同步器" class="header-tag" style="font-size:1rem;margin-left:3rem;">同步器</a><a href="#countdownlatch" class="header-tag" style="font-size:1rem;margin-left:4rem;">CountDownLatch</a><a href="#cyclicbarrier" class="header-tag" style="font-size:1rem;margin-left:4rem;">CyclicBarrier</a><a href="#semaphore" class="header-tag" style="font-size:1rem;margin-left:4rem;">Semaphore</a><a href="#exchanger" class="header-tag" style="font-size:1rem;margin-left:4rem;">Exchanger</a><a href="#blockingqueue" class="header-tag" style="font-size:1rem;margin-left:4rem;">BlockingQueue</a><a href="#线程安全" class="header-tag" style="font-size:1rem;margin-left:2rem;">线程安全</a><a href="#线程安全的级别" class="header-tag" style="font-size:1rem;margin-left:3rem;">线程安全的级别</a><a href="#stringbuffer" class="header-tag" style="font-size:1rem;margin-left:3rem;">StringBuffer</a><a href="#concurrenthashmap" class="header-tag" style="font-size:1rem;margin-left:3rem;">ConcurrentHashMap</a><a href="#concurrentskiplistmap-与-concurrentskiplistset" class="header-tag" style="font-size:1rem;margin-left:3rem;">ConcurrentSkipListMap 与 ConcurrentSkipListSet</a><a href="#concurrentlinkedqueue-与-concurrentlinkeddeque" class="header-tag" style="font-size:1rem;margin-left:3rem;">ConcurrentLinkedQueue 与 ConcurrentLinkedDeque</a><a href="#copyonwritearraylist-与-copyonwritearrayset" class="header-tag" style="font-size:1rem;margin-left:3rem;">CopyOnWriteArrayList 与 CopyOnWriteArraySet</a><a href="#反射编程" class="header-tag endtag" style="font-size:1rem;margin-left:1rem;">反射编程</a></div></div></div></div></aside><div id="curtain"></div><main id="main"><div class="__vuescroll" style="height:100%;width:100%;padding:0;position:relative;overflow:hidden;"><div class="__panel __hidebar" style="position:relative;box-sizing:border-box;height:100%;overflow-y:hidden;overflow-x:hidden;transform-origin:;transform:;"><div class="__view" style="position:relative;box-sizing:border-box;min-width:100%;min-height:100%;"><div class="margin-box"><div class="white-line"></div><div class="box"><div class="post-tags"><span class="post-tag ca-tag"><span><a class="firstca" style="color: white">程序设计</a><span><svg aria-hidden="true" focusable="false" data-prefix="fa" data-icon="caret-right" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512" class="svg-inline--fa fa-caret-right fa-w-6" style="width:1rem;"><path fill="currentColor" d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"></path></svg></span></span><span><a class="endcd" style="color: white">Java</a><!----></span></span><a class="ta-tag post-tag">java</a><span class="da-tag post-tag">2020.09.25</span><!----></div></div><div class="box"><h1 style="text-align:center;">Java 学习笔记</h1><div class="markdown-body content__default"><h1 id="java-学习笔记"><a href="#java-学习笔记" class="header-anchor">#</a> Java 学习笔记</h1> <p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的<strong>面向对象</strong>的程序设计语言，其设计宗旨是屏蔽底层开发的复杂性，提高开发效率。</p> <ul><li>语法方面，屏蔽了 C++ 中的操作符重载、多继承、指针等复杂特性，增加了类型自动转换、自动垃圾回收、异常处理等特性</li> <li>编译方面，引入虚拟机 JVM，屏蔽了多平台的差异，只需要将源代码编译成可在虚拟机中运行的字节码，便可以在多平台运行，并且支持字节码动态创建和修改</li></ul> <h2 id="注释"><a href="#注释" class="header-anchor">#</a> 注释</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 单行注释</span>

<span class="token comment">/*
多
行
注
释
*/</span>

<span class="token comment">/**
 * 文档注释
 * @author xxx
 * @param xxx xxx
 * @exception xxx xxx
 * @return xxx
 * @version xxx
 * @deprecated xxx
 */</span>
</code></pre></div><h2 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h2> <p>Java 是强类型语言</p> <div class="language-java extra-class"><pre class="language-java"><code>_type _name <span class="token operator">=</span> _init_value<span class="token punctuation">;</span>
</code></pre></div><ul><li>所有标识符必须先声明后使用</li> <li>所有标识符具有一个类型，并接受指定类型的值</li> <li>由字母、数字、下划线<code>_</code>、美元符<code>$</code>组成</li> <li>不能以数字开头</li> <li>不能直接使用<code>_</code>作为标识</li> <li>不能与 Java 关键字同名</li></ul> <h2 id="类型系统"><a href="#类型系统" class="header-anchor">#</a> 类型系统</h2> <table><thead><tr><th>数据类型</th> <th>种类</th> <th>存储方式</th></tr></thead> <tbody><tr><td>基本类型</td> <td>byte、short、int、long、char、float、double、boolean</td> <td>值</td></tr> <tr><td>引用类型</td> <td>数组、类、接口</td> <td>指针</td></tr></tbody></table> <h3 id="整型"><a href="#整型" class="header-anchor">#</a> 整型</h3> <table><thead><tr><th>类型名称</th> <th>占用位数</th> <th>表示范围</th></tr></thead> <tbody><tr><td>byte</td> <td>8 bits</td> <td>-128 ~ 127</td></tr> <tr><td>short</td> <td>16 bits</td> <td>-32,768 ~ 32,767</td></tr> <tr><td>int</td> <td>32 bits</td> <td>-2,147,483,648 ~ 2,147,483,647</td></tr> <tr><td>long</td> <td>64 bits</td> <td>-9.22e18 ~ 9.22e18</td></tr></tbody></table> <blockquote><p><strong>整型直接量表示法</strong></p> <ul><li><p>十进制 <code>nnn</code></p></li> <li><p>二进制 <code>0Bnnn</code></p></li> <li><p>八进制 <code>0nnn</code></p></li> <li><p>十六进制 <code>0Xnnn</code></p></li> <li><p>所有整形直接量默认按照 int 类型来处理，后缀<code>L</code>可以改为 long 处理</p></li></ul></blockquote> <h3 id="字符型"><a href="#字符型" class="header-anchor">#</a> 字符型</h3> <p>char 代表字符型。Java 采用 16 位的 Unicode 字符集作为编码方式。</p> <blockquote><p><strong>字符型直接量表示法</strong></p> <ul><li>单个字符 <code>'A'</code></li> <li>转义字符 <code>'\n'</code></li> <li>Unicode 值 <code>\uXXXX</code></li> <li>整形直接量直接赋值</li></ul></blockquote> <h3 id="浮点型"><a href="#浮点型" class="header-anchor">#</a> 浮点型</h3> <table><thead><tr><th>类型名称</th> <th>占用位数</th> <th>IEEE 754 标准</th></tr></thead> <tbody><tr><td>float</td> <td>32 bits</td> <td>1/8/23</td></tr> <tr><td>double</td> <td>64 bits</td> <td>1/11/52</td></tr></tbody></table> <blockquote><p><strong>进制转换中的精度损失</strong></p> <p>当浮点数进行从十进制转换成二进制时则可能存在精度损失。解决方案是采用 BigDecimal 类。</p></blockquote> <blockquote><p><strong>浮点型直接量表示法</strong></p> <ul><li>小数点 <code>0.1</code></li> <li>科学计数法 <code>5.12E2</code></li> <li>所有浮点型直接量默认按照 double 类型来处理，后缀<code>F</code>可以改为 float 处理</li> <li>浮点数支持正无穷大、负无穷大、非数</li></ul></blockquote> <h3 id="布尔型"><a href="#布尔型" class="header-anchor">#</a> 布尔型</h3> <p>boolean 代表布尔型，占用 8 bits ，使用 true / false 表示</p> <blockquote><p>基本类型自动转换</p> <p><img src="data:image/png;base64,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" alt="1565522372900"></p></blockquote> <h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <p><code>_type[]</code> 代表数组，指针指向一段大小相同连续排列的内存片段。</p> <div class="language-java extra-class"><pre class="language-java"><code>_type<span class="token punctuation">[</span><span class="token punctuation">]</span> _name <span class="token operator">=</span> <span class="token keyword">new</span> _type<span class="token punctuation">[</span>_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
_type<span class="token punctuation">[</span><span class="token punctuation">]</span> _name <span class="token operator">=</span> <span class="token punctuation">{</span>xxx<span class="token punctuation">,</span> xxx<span class="token punctuation">,</span> xxx<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>数组定义允许嵌套，即 <code>_type[][]</code></p></blockquote> <h3 id="类与接口"><a href="#类与接口" class="header-anchor">#</a> 类与接口</h3> <p>类与接口是 Java 类型的拓展机制，任何标准库的和自定义的类与接口都被当做类型，运用在 Java 的源代码中。</p> <h2 id="运算符"><a href="#运算符" class="header-anchor">#</a> 运算符</h2> <p>运算符用于实现最基本的逻辑功能。</p> <h3 id="算术运算符"><a href="#算术运算符" class="header-anchor">#</a> 算术运算符</h3> <ul><li><code>+</code> 加、字符串连接</li> <li><code>-</code> 减</li> <li><code>*</code> 乘</li> <li><code>/</code> 除</li> <li><code>%</code> 求余</li> <li><code>++</code> 自加</li> <li><code>--</code> 自减</li></ul> <blockquote><ul><li>浮点数可以对 0.0 作除或者求余</li> <li>自加和自减：放在左，先操作；放在右，后操作</li></ul></blockquote> <h3 id="位运算符"><a href="#位运算符" class="header-anchor">#</a> 位运算符</h3> <ul><li><code>&amp;</code> 按位与</li> <li><code>|</code> 按位或</li> <li><code>~</code> 按位非</li> <li><code>^</code> 按位异或</li> <li><code>&lt;&lt;</code> 左移补零</li> <li><code>&gt;&gt;</code> 右移补符号位</li> <li><code>&gt;&gt;&gt;</code> 右移补零</li></ul> <h3 id="赋值运算符"><a href="#赋值运算符" class="header-anchor">#</a> 赋值运算符</h3> <ul><li><code>=</code> 直接赋值</li> <li><code>+= -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></li></ul> <h3 id="比较运算符"><a href="#比较运算符" class="header-anchor">#</a> 比较运算符</h3> <ul><li><code>&gt;</code></li> <li><code>&lt;</code></li> <li><code>&gt;=</code></li> <li><code>&lt;=</code></li> <li><code>==</code></li> <li><code>!=</code></li></ul> <h3 id="逻辑运算符"><a href="#逻辑运算符" class="header-anchor">#</a> 逻辑运算符</h3> <ul><li><code>&amp;&amp;</code></li> <li><code>&amp;</code></li> <li><code>||</code></li> <li><code>|</code></li> <li><code>!</code></li> <li><code>^</code></li></ul> <h3 id="条件运算符"><a href="#条件运算符" class="header-anchor">#</a> 条件运算符</h3> <ul><li><code>xxx ? xxx : xxx</code></li></ul> <h2 id="流控制"><a href="#流控制" class="header-anchor">#</a> 流控制</h2> <h3 id="选择结构"><a href="#选择结构" class="header-anchor">#</a> 选择结构</h3> <h4 id="if"><a href="#if" class="header-anchor">#</a> if</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>_logic_exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>_logic_exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_logic_exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="switch"><a href="#switch" class="header-anchor">#</a> switch</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">switch</span><span class="token punctuation">(</span>_exp<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">case</span> _value<span class="token operator">:</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> _value<span class="token operator">:</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="循环结构"><a href="#循环结构" class="header-anchor">#</a> 循环结构</h3> <h4 id="for"><a href="#for" class="header-anchor">#</a> for</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>_init<span class="token punctuation">;</span> _logic_exp<span class="token punctuation">;</span> _post<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>_type xxx<span class="token operator">:</span> _array_exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="while"><a href="#while" class="header-anchor">#</a> while</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span>_logic_exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">do</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>_logic_exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><ul><li>continue 继续下一轮循环</li> <li>break 跳出循环，或跳出 switch 判断</li></ul></blockquote> <h2 id="类与对象"><a href="#类与对象" class="header-anchor">#</a> 类与对象</h2> <h3 id="类定义"><a href="#类定义" class="header-anchor">#</a> 类定义</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span></span><span class="token class-name">Xxx</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span></span><span class="token class-name">Xxx</span><span class="token punctuation">.</span>xxx<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Xxx</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> _type xxx<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> _type<span class="token operator">/</span><span class="token keyword">void</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    
    _type xxx<span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    
    <span class="token class-name">Xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    
    _type<span class="token operator">/</span><span class="token keyword">void</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="包机制"><a href="#包机制" class="header-anchor">#</a> 包机制</h4> <p>package 定义了类所属的包空间，当缺省时，将使用默认包空间，即根空间。</p> <p>import 引入了该类所用到的其他包空间的类定义；import static 引入了该类所用到的其他包空间的类的静态成员。如果没有引入或者有重名问题，需要在源代码中使用类的全限定名，即包名+类名。</p> <h4 id="static"><a href="#static" class="header-anchor">#</a> static</h4> <p>类也是一种特殊的对象，它们都是 java.lang.Class 的实例对象。static 修饰的变量和方法属于类成员。</p> <h4 id="变量成员"><a href="#变量成员" class="header-anchor">#</a> 变量成员</h4> <p>在类中定义的变量称为变量成员</p> <ul><li>被 final 修饰的变量成员只能被赋值一次。</li></ul> <h4 id="初始化块"><a href="#初始化块" class="header-anchor">#</a> 初始化块</h4> <p>初始化块将在变量成员赋初始值后执行。</p> <h4 id="构造器"><a href="#构造器" class="header-anchor">#</a> 构造器</h4> <p>构造器负责对象的实例化，在初始化块执行之后再执行。缺省时，会默认提供一个空执行体的无参构造器；否则不会默认提供一个空执行体的无参构造器，需要显式定义。</p> <h4 id="方法成员"><a href="#方法成员" class="header-anchor">#</a> 方法成员</h4> <p>方法不能独立存在，必须定义在合适的类中。</p> <ul><li>形参采用值传递的方式</li> <li>执行体中可以定义局部变量，被 final 修饰时只能被赋值一次</li> <li>Java 支持方法重载，即方法名相同但形参不同，编译器根据方法形参列表和最小类型原则来确定方法调用</li> <li>Java 支持方法递归调用</li></ul> <blockquote><p>最小类型原则：当有多个方法匹配时，则根据继承关系，选择最小的类型所对应的方法</p></blockquote> <h4 id="注解"><a href="#注解" class="header-anchor">#</a> 注解</h4> <h3 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h3> <table><thead><tr><th>修饰符名称</th> <th style="text-align:center;">同一个类中</th> <th style="text-align:center;">同一个包中</th> <th style="text-align:center;">子类中</th> <th style="text-align:center;">全局范围内</th></tr></thead> <tbody><tr><td>private</td> <td style="text-align:center;">O</td> <td style="text-align:center;">X</td> <td style="text-align:center;">X</td> <td style="text-align:center;">X</td></tr> <tr><td>default</td> <td style="text-align:center;">O</td> <td style="text-align:center;">O</td> <td style="text-align:center;">X</td> <td style="text-align:center;">X</td></tr> <tr><td>protected</td> <td style="text-align:center;">O</td> <td style="text-align:center;">O</td> <td style="text-align:center;">O</td> <td style="text-align:center;">X</td></tr> <tr><td>public</td> <td style="text-align:center;">O</td> <td style="text-align:center;">O</td> <td style="text-align:center;">O</td> <td style="text-align:center;">O</td></tr></tbody></table> <blockquote><p>default 表示不加任何访问控制符</p></blockquote> <blockquote><p>外部类也可以使用访问控制符来修饰，支持 public 和 default。当外部类使用 public 修饰时，文件名必须和该类名一致，因此一个源文件中只能有一个 public 类。</p></blockquote> <h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <p>非私有的非静态的成员（构造器除外）都可以被子类继承。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Xxx</span> <span class="token keyword">extends</span> <span class="token class-name">Xxx</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>在构造器中，this(xxx) 调用其他构造器。缺省时，会在开头隐式调用父类的无参构造器；也可以通过 super(xxx) 显式调用父类构造器；当父类没有无参构造器时，必须显式调用。</li> <li>this 代表当前对象，super 代表当前对象的父类对象。</li> <li>被 final 修饰的类无法被继承</li></ul> <h3 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h3> <p>可以通过变量调用编译时类型的方法，但如果运行时类型重写了编译时类型的方法，则变量会优先调用运行时类型的方法。由于运行时类型不固定，相同类型的变量在调用同一个方法时就可能表现出不同的行为特征，这就是多态。</p> <ul><li>方法重写必须满足，形参列表相同，返回值类型相同或更小，访问控制符相同或更大，捕获的异常类型相同或者更小，异常数量相同或更少</li> <li>多态只适用于成员方法，对于成员变量来说，不会优先访问运行时类型的重名成员变量</li> <li>被 final 修饰的方法无法被重写</li></ul> <blockquote><p><strong>强制类型转换</strong></p> <table><thead><tr><th></th> <th>自动类型转换</th> <th>强制类型转换</th></tr></thead> <tbody><tr><td>基本类型</td> <td>小类型 <code>--&gt;</code> 大类型</td> <td>大类型 <code>--&gt;</code> 小类型</td></tr> <tr><td>引用类型（类）</td> <td>子类 <code>--&gt;</code> 父类 （多态）</td> <td>父类 <code>--&gt;</code> 子类</td></tr></tbody></table> <p>强制类型转换的格式 <code>(targetType)xxx</code></p></blockquote> <h4 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Xxx</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Xxx</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果一个类至少有一个成员方法没有执行体，则该类为抽象类。</p> <ul><li>抽象类需要被 abstract 修饰</li> <li>没有执行体的方法可能来自 abstract 修饰的成员方法，可能来自于父类 abstract 成员方法，也可能来自未实现的接口方法。</li> <li>抽象类无法被实例化</li></ul> <blockquote><p>抽象类中的 this 和 子类中的 super</p> <p>抽象类也可以有自己的构造器，底层也可以创建自己的实例，但是这样的实例是个“半成品”，是无法被直接使用的。相应的 this、super 并不代表抽象类实例，而是代表那个“半成品”</p></blockquote> <h4 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h4> <p>接口是彻底抽象的一种类，每一个成员方法都默认添加了 public abstract 修饰，因为彻底抽象，放宽了限制，原本类仅支持单继承，接口则支持多实现。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Xxx</span> <span class="token punctuation">{</span>
    <span class="token class-name">Xxx</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Xxx</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Lambda 表达式</p></blockquote> <h3 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h3> <p>内部类可以更好地封装在外部类中。</p> <h4 id="非静态内部类"><a href="#非静态内部类" class="header-anchor">#</a> 非静态内部类</h4> <ul><li><p>支持4种访问控制模式</p></li> <li><p>可直接访问外部类的所有成员</p></li> <li><p>不允许在非静态内部类定义静态成员。</p></li> <li><p>外部非静态类成员可以通过创建内部类对象间接访问内部类成员</p></li> <li><p>同名对策：外部类名.this.外部类非静态成员名；外部类名.外部类静态成员名</p></li> <li><p>在外部类之外访问非静态内部类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Out</span><span class="token punctuation">.</span><span class="token class-name">In</span> varName <span class="token operator">=</span> <span class="token class-name">OutInstance</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">In</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>定义非静态内部类的子类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Out</span><span class="token punctuation">.</span><span class="token class-name">In</span> <span class="token punctuation">{</span>
    <span class="token comment">//必须显式定义</span>
    <span class="token keyword">public</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token class-name">Out</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        out<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="静态内部类"><a href="#静态内部类" class="header-anchor">#</a> 静态内部类</h4> <ul><li><p>支持4种访问控制模式</p></li> <li><p>可直接访问外部类的所有静态成员</p></li> <li><p>允许在静态内部类定义静态成员。</p></li> <li><p>外部类成员可以通过内部类名或者创建内部类对象间接访问内部类成员</p></li> <li><p>同名对策：外部类名.外部类静态成员名</p></li> <li><p>在外部类之外访问静态内部类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Out</span><span class="token punctuation">.</span><span class="token class-name">StaticIn</span> varName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Out</span><span class="token punctuation">.</span><span class="token class-name">StaticIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>定义静态内部类的子类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Out</span><span class="token punctuation">.</span><span class="token class-name">StaticIn</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="局部类对象"><a href="#局部类对象" class="header-anchor">#</a> 局部类对象</h3> <h4 id="匿名局部类对象"><a href="#匿名局部类对象" class="header-anchor">#</a> 匿名局部类对象</h4> <p>只需要使用一次的类，会立即创建对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">new</span> 接口名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token keyword">new</span> 抽象类名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre></div><blockquote><p>被匿名内部类访问的局部变量，会自动被 final 修饰。</p></blockquote> <h4 id="lambda-表达式对象"><a href="#lambda-表达式对象" class="header-anchor">#</a> Lambda 表达式对象</h4> <p>Lambda 表达式已被很多编程语言所支持，它本身代表一个匿名函数。但是 Java 中，方法必须定义在类里。为了支持Lambda 表达式特性，Java 提出了“函数式接口”的概念，即只包含一个抽象方法的接口，用于支持 Lambda 表达式。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> $函数式接口名 <span class="token punctuation">{</span>
    <span class="token comment">//一个抽象方法</span>
    $返回值类型 $方法名<span class="token punctuation">(</span>$形参列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//对应哪个函数式接口则取决于上下文</span>
<span class="token punctuation">(</span>$形参列表<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> $抽象方法体 <span class="token punctuation">}</span>
</code></pre></div><ul><li><p>如果参数只有一个，可以省略括号。</p></li> <li><p>形参列表中的类型声明可以省略。</p></li> <li><p>如果方法体只有一句，可以省略花括号，如果有，则可以省略句中的 return 。</p></li> <li><p>进一步，根据这一句不同情形，可以使用 <code>::</code> 让其更加简洁</p> <table><thead><tr><th>情形</th> <th>原始 Lambda 表达式</th> <th>简化后的表达式</th></tr></thead> <tbody><tr><td>调用类方法</td> <td><code>(a,b,...) -&gt; 类名.类方法(a,b,...)</code></td> <td><code>类名::类方法</code></td></tr> <tr><td>调用对象方法</td> <td><code>(a,b,...) -&gt; 对象.对象方法(a,b,...)</code></td> <td><code>对象::对象方法</code></td></tr> <tr><td>调用类对象方法</td> <td><code>(a,b,...) -&gt; a.对象方法(a,b,...)</code></td> <td><code>类名::对象方法</code></td></tr> <tr><td>调用构造器</td> <td><code>(a,b,...) -&gt; new 类名(a,b,...)</code></td> <td><code>类名::new</code></td></tr></tbody></table></li></ul> <h3 id="枚举类"><a href="#枚举类" class="header-anchor">#</a> 枚举类</h3> <p>枚举类的对象是有限且固定的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Season</span> <span class="token punctuation">{</span>
    SPRING<span class="token punctuation">,</span>SUMMER<span class="token punctuation">,</span>FALL<span class="token punctuation">,</span>WINTER<span class="token punctuation">;</span> <span class="token comment">//必须写在开头处</span>
<span class="token punctuation">}</span>
<span class="token comment">// 外部使用 &lt;枚举类名&gt;.&lt;枚举值名&gt; 来使用</span>
</code></pre></div><ul><li><p>枚举类可以定义成员变量、方法、构造器。</p></li> <li><p>构造器只能是私有的，且如果有参数，每一个枚举值也要加上实参。</p></li> <li><p>如果包含抽象方法或者实现了接口，每一个枚举值也要实现这些抽象方法和接口方法。</p></li> <li><p>枚举类可以实现多个接口，但不能继承，也不可以被继承。</p></li></ul> <h3 id="类加载与对象实例化"><a href="#类加载与对象实例化" class="header-anchor">#</a> 类加载与对象实例化</h3> <p><img src="/assets/img/1565855768599.fb27bc7d.png" alt="1565855768599"></p> <h3 id="垃圾回收"><a href="#垃圾回收" class="header-anchor">#</a> 垃圾回收</h3> <p>当某一对象失去所有引用时，就变成垃圾等待回收。</p> <p><img src="/assets/img/1565683593252.158b27fa.png" alt="1565683593252"></p> <ul><li>不要主动调用 finalize()</li> <li>可能程序执行完毕也不会调用 finalize()</li> <li><code>System.gc()</code> 通知系统进行垃圾回收</li></ul> <h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <blockquote><p>引用类型的强制类型转换有个弊端，编译时并不会去检查是否可以转换成功，运行时就容易引起 ClassCastException 异常。Java 5 以后，引入了泛型，将类型检查提前到了编译阶段，让程序更加健壮。</p></blockquote> <p>泛型的原义是“参数化类型”，即在定义类或者方法时指定一个参数化的类型，调用时则传入具体的类型，提供语言内置的类型检查机制，如果出现与类型不符的情况将无法通过编译。</p> <h3 id="泛型类、接口"><a href="#泛型类、接口" class="header-anchor">#</a> 泛型类、接口</h3> <div class="language-java extra-class"><pre class="language-java"><code>$修饰符 <span class="token keyword">class</span><span class="token operator">/</span><span class="token keyword">interface</span> $类名<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> <span class="token comment">// 泛型声明在类名之后</span>
    <span class="token comment">// 内部或者继承或者实现里都可以使用类型 E T,就像函数里使用参数一样。</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>创建泛型类对象时需要显式指定类型参数值。</li> <li>声明的泛型不能直接作为父类或者接口，但可以作为父类或者接口的泛型参数使用。</li> <li>声明的泛型不能创建泛型类型数组，编译器无法确定实际类型，也就无法分配内存。</li> <li>泛型类这个概念本身就是针对对象而言的，所有的类成员不允许使用泛型。</li></ul> <h3 id="泛型方法"><a href="#泛型方法" class="header-anchor">#</a> 泛型方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token comment">//泛型方法</span>
    $修饰符 <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> $返回值类型 $方法名<span class="token punctuation">(</span>$形参列表<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//泛型声明在修饰符之后</span>
        <span class="token comment">//内部或返回值类型或形参列表都可以使用类型 E T</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre></div><ul><li>访问泛型方法时不需要显式指定类型参数值，编译器将根据调用上下文来推断类型参数值。</li> <li>访问泛型方法时也可以显式指定类型参数值，在方法名前添加<code>&lt;&gt;</code>即可</li> <li>声明的泛型能够直接作为返回值类型、形参类型。</li> <li>声明的泛型允许创建泛型类型数组。</li> <li>泛型方法这个概念被用来表示方法的形参与形参、形参与返回值之间的类型依赖关系。</li></ul> <blockquote><p><strong>泛型构造器</strong>同泛型方法的用法一样。</p></blockquote> <h3 id="类型通配符"><a href="#类型通配符" class="header-anchor">#</a> 类型通配符</h3> <p>在使用泛型类的过程中，必须向运行时类型传入具体的类型，而 Java 允许向编译时类型传入一个类型范围，比如是某类的子类、是某类的父类等等。此时就需要用到类型通配符 <code>?</code> 。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span>xxx<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&gt;</span></span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Child</span><span class="token punctuation">&gt;</span></span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Father</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>由于使用通配符，导致泛型的类型不确定，所以变量无法访问一切与泛型相关的方法成员和变量成员，比如List&lt;?&gt; list 不可以访问 add() 方法，但可以访问 get() 方法。</p> <blockquote><p>声明泛型时也可以使用 extends、super 来限定泛型的范围，并且能够访问范围上限类型里面的方法成员和变量成员。</p></blockquote> <h3 id="原始类型"><a href="#原始类型" class="header-anchor">#</a> 原始类型</h3> <p>如果没有为泛型类指定实际的类型参数，将成为“原始类型”，类型参数为上限类型。</p> <ul><li><p>任何泛型类对象都可以赋值给原始类型变量，这称为“类型擦除”</p></li> <li><p>原始类型对象可以赋值给任何泛型类变量，这称为“类型转换”，但系统会发出警告。</p></li> <li><p>Java 不允许直接创建泛型数组。如果想要使用泛型类数组，必须通过原始类型创建：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> lsa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
lsa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div></li></ul> <h2 id="异常处理"><a href="#异常处理" class="header-anchor">#</a> 异常处理</h2> <table><thead><tr><th></th> <th>含义</th> <th>程序流</th></tr></thead> <tbody><tr><td>Checked 异常</td> <td>继承 Exception</td> <td>强制处理</td></tr> <tr><td>Runtime 异常</td> <td>继承 RuntimeException</td> <td>无需处理</td></tr></tbody></table> <h3 id="异常处理机制"><a href="#异常处理机制" class="header-anchor">#</a> 异常处理机制</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token comment">//方法、构造器</span>
    xxx xxx <span class="token function">xxx</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">XxxException</span> <span class="token punctuation">{</span>
        <span class="token comment">//...</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//...</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">XxxException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//...</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">XxxException</span> e2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//...</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">//...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li>try <code>()</code> 中创建可自动回收的资源</li> <li>运行 try 块代码</li> <li>遇到异常，不再继续执行 try 块，依次寻找 catch 块是否与异常匹配</li> <li>如果匹配，则执行相应的 catch 块，再执行 finally 块</li> <li>如果未匹配，则直接执行 finally 块</li> <li>方法体可以继续抛出未处理的异常，交给外部程序处理。</li></ol> <blockquote><p>Check 异常必须被 catch 或者被 throws 。Runtime 异常则没有限制，但是如果没有得到处理，将直接终止程序运行。</p></blockquote> <blockquote><p>如果 catch 的多个异常中有父子关系，需将子类异常放到前面。</p></blockquote> <blockquote><p>方法体抛出异常，当重写该方法时，抛出的异常只能更小，且只能更少。</p></blockquote> <h3 id="异常类"><a href="#异常类" class="header-anchor">#</a> 异常类</h3> <p><img src="/assets/img/1565832450216.64b3fe3f.png" alt="1565832450216"></p> <p>Throwable 常用方法：</p> <ul><li><code>String getMessage()</code> 返回此throwable的详细消息字符串。</li> <li><code>void printStackTrace()</code> 将此throwable和其追溯打印到标准错误流。</li> <li><code>void printStackTrace(PrintStream s)</code> 将此throwable和其追溯打印到指定的打印流。</li></ul> <p>自定义异常类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token operator">/</span><span class="token class-name">RuntimeException</span><span class="token operator">/</span><span class="token class-name">XxxException</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="命令行工具"><a href="#命令行工具" class="header-anchor">#</a> 命令行工具</h2> <h3 id="javac"><a href="#javac" class="header-anchor">#</a> javac</h3> <div class="language-sh extra-class"><pre class="language-sh"><code>$ javac -cp xxx.jar:xxx.jar -d xxx/ xxx.java xxx.java
</code></pre></div><h3 id="jar"><a href="#jar" class="header-anchor">#</a> jar</h3> <div class="language-sh extra-class"><pre class="language-sh"><code>$ jar -c -v -f xxx/xxx.jar -e Xxx -C xxx/ Xxx.class Xxx.class
$ jar -t -v -f xxx/xxx.jar
$ jar -x -v -f xxx/xxx.jar
</code></pre></div><h3 id="java"><a href="#java" class="header-anchor">#</a> java</h3> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># java程序的入口是主类中的 main 函数</span>
$ java -cp xxx.java:xxx.java -Dxxx<span class="token operator">=</span>xxx Xxx xxx xxx <span class="token punctuation">..</span>.
<span class="token comment"># 可直接运行的jar</span>
$ java --jar xxx/xxx.jar
</code></pre></div><h3 id="javadoc"><a href="#javadoc" class="header-anchor">#</a> javadoc</h3> <h3 id="jps"><a href="#jps" class="header-anchor">#</a> jps</h3> <h3 id="jshell"><a href="#jshell" class="header-anchor">#</a> jshell</h3> <h2 id="项目管理工具"><a href="#项目管理工具" class="header-anchor">#</a> 项目管理工具</h2> <h3 id="maven"><a href="#maven" class="header-anchor">#</a> maven</h3> <h3 id="gradle"><a href="#gradle" class="header-anchor">#</a> gradle</h3> <h2 id="核心类"><a href="#核心类" class="header-anchor">#</a> 核心类</h2> <h3 id="ojbect"><a href="#ojbect" class="header-anchor">#</a> Ojbect</h3> <h3 id="包装类"><a href="#包装类" class="header-anchor">#</a> 包装类</h3> <h3 id="string"><a href="#string" class="header-anchor">#</a> String</h3> <h3 id="system"><a href="#system" class="header-anchor">#</a> System</h3> <h3 id="runtime"><a href="#runtime" class="header-anchor">#</a> Runtime</h3> <h2 id="集合类"><a href="#集合类" class="header-anchor">#</a> 集合类</h2> <h3 id="collection"><a href="#collection" class="header-anchor">#</a> Collection</h3> <h4 id="set"><a href="#set" class="header-anchor">#</a> Set</h4> <h4 id="list"><a href="#list" class="header-anchor">#</a> List</h4> <h4 id="queue"><a href="#queue" class="header-anchor">#</a> Queue</h4> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <h2 id="i-o-类"><a href="#i-o-类" class="header-anchor">#</a> I/O 类</h2> <h2 id="工具类"><a href="#工具类" class="header-anchor">#</a> 工具类</h2> <h3 id="arrays"><a href="#arrays" class="header-anchor">#</a> Arrays</h3> <h3 id="collections"><a href="#collections" class="header-anchor">#</a> Collections</h3> <h2 id="网络编程"><a href="#网络编程" class="header-anchor">#</a> 网络编程</h2> <h2 id="并发编程"><a href="#并发编程" class="header-anchor">#</a> 并发编程</h2> <h3 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h3> <h4 id="thread"><a href="#thread" class="header-anchor">#</a> Thread</h4> <p>Thread 类是线程在 Java 中的抽象。主要 <strong>API</strong> 如下</p> <ul><li><p><code>static Thread currentThread()</code></p></li> <li><p><code>Thread(Runnable r)</code> 使用当前线程的线程组创建</p></li> <li><p><code>Thread(ThreadGroup g, Runnable r)</code></p></li> <li><p><code>void setPriority(int p)</code></p> <blockquote><p>每当调度器决定运行一个新线程时， 首先会在具有高优先级的线程中进行选择， 尽管这样会使低优先级的线程完全饿死</p></blockquote> <p><code>static int Thread.MAX_PRIORITY</code></p> <p><code>static int Thread.MIN_PRIORITY</code></p> <p><code>static int Thread.NORM_PRIORITY</code></p></li> <li><p><code>void setDaemon(boolean b)</code> 设置是否为后台线程</p> <blockquote><p>后台线程的任务是为其他线程提供服务，如果全部前台线程死亡，后台线程会自动死亡</p></blockquote></li> <li><p><code>void start()</code> 激活线程，进入执行状态，不可以二次调用。JVM 会自动注册一个该线程的强引用，所以即使没有显式的变量引用线程，活跃的线程依然不会被垃圾回收器回收。</p></li> <li><p><code>static void sleep(long millis)</code> 当前线程进入限时等待状态，指定时间长度后自动恢复执行状态</p></li> <li><p><code>static void yield()</code> 主动让当前线程失去CPU</p></li> <li><p><code>void join()</code> 等待该线程实例执行完毕</p></li> <li><p><code>void interrupt()</code> 将线程标记为“中断”，具体如何中断由 <code>run()</code> 的顺序流决定</p> <blockquote><p>如果线程调用了对象的 <code>wait</code>方法，或者线程对象的 <code>join</code> 方法，或者调用了 <code>Thread.sleep</code> 方法，该方法将清除中断状态，并抛出<code>InterruptedException</code> 给这个线程。</p> <p>如果线程阻塞在 <code>InterruptibleChannel</code> 上，该方法将设置中断状态，并抛出 <code>ClosedByInterruptException</code> 给这个线程。</p></blockquote></li> <li><p><code>boolean isInterrupted()</code> 判断线程是否为“中断”</p></li> <li><p><code>static boolean interrupted()</code> 判断当前线程是否为“中断”，并清除中断状态</p></li> <li><p><code>setContextClassLoader</code></p> <blockquote><p>SPI 是服务提供者接口机制，是一种动态加载服务提供者类的方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//load方法会搜索类路径下的 META-INF/services/$(MyServices全路径名) 这个文件</span>
<span class="token comment">//文件中罗列了这个服务的实现类的全路径名</span>
<span class="token comment">//根据这些名利用线程上下文类加载器去加载类</span>
<span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyService</span><span class="token punctuation">&gt;</span></span> myServices <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">MyService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyService</span><span class="token punctuation">&gt;</span></span> myServiceIterator <span class="token operator">=</span> myServices<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>myServiceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">MyService</span> myService <span class="token operator">=</span> myServiceIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote></li></ul> <h5 id="thread-state"><a href="#thread-state" class="header-anchor">#</a> Thread.State</h5> <p>Thread.State 表示线程状态的枚举类</p> <ul><li><p><code>NEW</code> 新建的线程对象还未执行</p></li> <li><p><code>RUNNABLE</code> 线程正在 JVM 中被执行</p></li> <li><p><code>BLOCKED</code> 等待获取监视器锁</p> <blockquote><p>进入synchronized 临界区或者调用 Object#wait 后唤醒时，进入 BLOCKED 状态</p></blockquote></li> <li><p><code>WAITING</code> 无限期等待，直到被其他线程唤醒（Object）</p> <blockquote><p>Object#wait()、Thread#join()、LockSupport#park() 会使线程进入 WAITING 状态</p></blockquote></li> <li><p><code>TIMED_WAITING</code> 限时等待，直到被其他线程唤醒或者时限达到自我唤醒</p> <blockquote><p>Thread.sleep(xxx)、Object#wait(xxx)、Thread#join(xxx)、LockSupport#parkXXX(xxx) 会使线程进入 TIMED_WAITING 状态</p></blockquote></li> <li><p><code>TERMINATED</code> 线程终止，不可二次执行</p></li></ul> <blockquote><p>因 IO 操作而阻塞的线程其实还是 RUNNABLE 的状态</p></blockquote> <h5 id="threadgroup"><a href="#threadgroup" class="header-anchor">#</a> ThreadGroup</h5> <p>ThreadGroup 类是线程组在 Java 中的抽象，主要的 API 如下：</p> <ul><li><code>ThreadGroup(String name)</code></li> <li><code>ThreadGroup(ThreadGroup g, String name)</code></li> <li><code>void interrupt()</code></li> <li><code>void setDaemon(boolean b)</code></li></ul> <h5 id="thread-uncaughtexceptionhandler"><a href="#thread-uncaughtexceptionhandler" class="header-anchor">#</a> Thread.UncaughtExceptionHandler</h5> <p>表示一个非受检异常处理器，ThreadGroup 实现了 Thread.UncaughtExceptionHandler ，API：</p> <ul><li><code>void uncaughtException(Thread t, Throwable e)</code></li></ul> <p>设置处理器的方法如下：</p> <ul><li><code>void Thread#setUncaughtExceptionHandler(UncaughtExceptionHandler h)</code> 设置线程的处理器</li> <li><code>void Thread.setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler h)</code> 设置默认的处理器</li></ul> <p>用于处理线程执行过程中的非受检异常，其处理流程如下：</p> <ol><li>如果线程设置了处理器，那么交给线程处理器处理</li> <li>否则交给线程所在的线程组处理，其中默认实现如下
<ol><li>如果线程组有父线程组，那么就给父线程组处理</li> <li>否则，如果有默认异常处理器，则交给该处理器处理</li> <li>否则，输出栈轨迹到标准错误流上</li></ol></li></ol> <h5 id="threadlocal-t"><a href="#threadlocal-t" class="header-anchor">#</a> ThreadLocal&lt;T&gt;</h5> <p>ThreadLocal 是局部线程变量的抽象。主要 API 如下：</p> <ul><li><code>T get()</code> 获取与当前线程关联的指定类型的对象</li> <li><code>void set(T value)</code> 设置与当前线程关联的指定类型的对象</li> <li><code>void remove()</code> 删除与当前线程关联的指定类型的对象</li> <li><code>static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;S&gt; s)</code> 生成一个有初始值的 ThreadLocal 对象</li></ul> <p>每一个线程都会持有一个 ThreadLocal.ThreadLocalMap 对象，该对象负责管理以 ThreadLocal 对象为 key 本地值为 value 的映射。而 ThreadLocal 对象自身不负责存储，而只负责访问或设置或删除当前线程的 ThreadLocal.ThreadLocalMap 对象的与自身对应的值对象。</p> <blockquote><p>ThreadLocalMap 对象持有 ThreadLocal key 的弱引用，所以当所有强引用失效后，即使没有手动删除，ThreadLocal 对象也会被回收，从而出现 null key 现象。但是 ThreadLocal 对象对应的值对象并没有自动删除，而是在下一次 ThreadLocalMap 调用set, get，remove的时候才会被清除，有内存泄漏的隐患。所以不要忽略 remove 方法的调用。</p></blockquote> <h5 id="runnable"><a href="#runnable" class="header-anchor">#</a> Runnable</h5> <p>Runnable 代表一个无返回值的执行体，该接口只包含一个方法：</p> <ul><li><code>void run()</code></li></ul> <p>Thread 实现了 Runnable 接口。默认将执行构造方法传入的 Runnable 对象的 run 方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnableObj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="callable-v"><a href="#callable-v" class="header-anchor">#</a> Callable&lt;V&gt;</h5> <p>Callable 代表一个有返回值的执行体，该接口只包含一个方法：</p> <ul><li><code>V call()</code></li></ul> <h5 id="future-v"><a href="#future-v" class="header-anchor">#</a> Future&lt;V&gt;</h5> <p>Future&lt;V&gt; 代表一个 Callable 执行体的管理器，提供了以下方法：</p> <ul><li><code>boolean cancel(boolean i)</code> 取消执行体，如果已经开始执行且 i 为 true ，则会尝试中断</li> <li><code>boolean isCancelled()</code></li> <li><code>boolean isDone()</code></li> <li><code>V get()</code> 尝试获取执行体的返回值，如果还未完成，线程会阻塞至任务完成</li> <li><code>V get(long timeout, TimeUnit unit)</code></li></ul> <h5 id="runnablefuture-v"><a href="#runnablefuture-v" class="header-anchor">#</a> RunnableFuture&lt;V&gt;</h5> <p>Callable 的执行体不能直接被线程对象接受，需要包装成 Runnable 对象。RunnableFuture&lt;V&gt; 同时继承了 Runnable 、 Future&lt;V&gt; 接口。</p> <h5 id="futuretask-v"><a href="#futuretask-v" class="header-anchor">#</a> FutureTask&lt;V&gt;</h5> <p>FutureTask 同时实现了 RunnableFuture&lt;V&gt; 接口。FutureTask 对象的 run 方法会调用内置的 Callable 对象的执行体，并随后保存返回值。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span>XXX<span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span>callableObj<span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">XXX</span> value <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="executor"><a href="#executor" class="header-anchor">#</a> Executor</h4> <p>Executor 表示一个执行器，</p> <ul><li><code>void execute(Runnable command)</code></li></ul> <h5 id="executorservice"><a href="#executorservice" class="header-anchor">#</a> ExecutorService</h5> <p>ExecutorService 接口是 Executor 的子接口，增加了执行器需要的完备的服务方法，主要有：</p> <ul><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li> <li><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;Callable&lt;T&gt;&gt; tasks)</code></li> <li><code>&lt;T&gt; T invokeAny(Collection&lt;Callable&lt;T&gt;&gt; tasks)</code></li> <li><code>void shutdown()</code></li> <li><code>List&lt;Runnable&gt; shutdownNow()</code></li></ul> <h5 id="threadpoolexecutor"><a href="#threadpoolexecutor" class="header-anchor">#</a> ThreadPoolExecutor</h5> <p>ThreadPoolExecutor 使用池化算法实现了 ExecutorService 。</p> <ul><li>减少创建和销毁线程的性能损耗</li> <li>有效地管理系统资源，防止系统崩溃</li></ul> <p>构造一个完整的 ThreadPoolExecutor 对象依次需要以下参数：</p> <ul><li><code>int corePoolSize</code> 线程池核心线程数</li> <li><code>int maximumPoolSize</code> 线程池最大线程数</li> <li><code>long keepAliveTime</code> 当线程数大于核心线程数时，空闲线程的等待时限</li> <li><code>TimeUnit unit</code></li> <li><code>BlockingQueue&lt;Runnable&gt; workQueue</code> 该阻塞队列用于存放 execute 方法提交的等待执行的任务</li> <li><code>ThreadFactory threadFactory</code> 线程工厂</li> <li><code>RejectedExecutionHandler handler</code> 拒绝执行处理器</li></ul> <blockquote><p>java.util.concurrent.Executors 是一个工具类，可以创建简单的线程池对象，但不推荐在生产环境中使用。</p></blockquote> <p>底层的执行流程如下：</p> <ol><li>execute 或 submit 方法提交任务</li> <li>如果当前线程数小于核心线程数，新建核心线程执行当前任务
<ol><li>执行完后，将一直从任务队列中取任务执行</li></ol></li> <li>否则，向任务队列添加当前任务，如果添加成功，返回</li> <li>否则，如果当前线程数小于最大线程数，新建非核心线程执行当前任务
<ol><li>执行完后，将一直从任务队列中取任务执行，如果一直闲置了足够长时间，将销毁该线程</li></ol></li> <li>否则，调用拒绝执行处理器的相关方法</li></ol> <h5 id="forkjoinpool"><a href="#forkjoinpool" class="header-anchor">#</a> ForkJoinPool</h5> <h5 id="scheduledexecutorservice"><a href="#scheduledexecutorservice" class="header-anchor">#</a> ScheduledExecutorService</h5> <p>ScheduledExecutorService 接口是 ExecutorService 的子接口，增加了任务调度方法：</p> <ul><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></li> <li><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></li> <li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></li> <li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></li></ul> <h5 id="scheduledthreadpoolexecutor"><a href="#scheduledthreadpoolexecutor" class="header-anchor">#</a> ScheduledThreadPoolExecutor</h5> <h4 id="completionservice-v"><a href="#completionservice-v" class="header-anchor">#</a> CompletionService&lt;V&gt;</h4> <p>CompletionService&lt;V&gt; 表示一个即可以接收任务也可以处理任务结果的服务，主要 API 如下：</p> <ul><li><code>Future&lt;V&gt; submit(Callable&lt;V&gt; task)</code> 提交任务</li> <li><code>Future&lt;V&gt; take()</code> 返回一个已经完成的任务结果，如果没有则阻塞</li> <li><code>Future&lt;V&gt; poll()</code> 非阻塞，如果没有任务完成则返回 null</li></ul> <blockquote><p>ExecutorService 只负责接收任务，接收的同时会返回 Future 对象给主调，所以不负责处理任务结果。</p></blockquote> <h5 id="executorcompletionservice-v"><a href="#executorcompletionservice-v" class="header-anchor">#</a> ExecutorCompletionService&lt;V&gt;</h5> <p>ExecutorCompletionService&lt;V&gt; 是 CompletionService&lt;V&gt; 的一种实现：</p> <ul><li><code>ExecutorCompletionService(Executor e)</code></li> <li><code>ExecutorCompletionService(Executor e, BlockingQueue&lt;Future&lt;V&gt;&gt; q)</code></li></ul> <p>底层维护了一个 Executor 对象和一个 BlockingQueue&lt;Future&lt;V&gt;&gt; 对象，当接收任务是会将任务对象包装成 QueueingFuture&lt;V&gt; 对象，该对象会在任务完成时自动将任务结果添加到阻塞队列中。</p> <h4 id="completionstage-t"><a href="#completionstage-t" class="header-anchor">#</a> CompletionStage&lt;T&gt;</h4> <p>CompetionStage&lt;T&gt; 表示一个异步计算的阶段，可以在计算完成时自动执行相应的处理：</p> <ul><li><code>&lt;U&gt; CompletionStage&lt;U&gt; thenApply(Function&lt;T,U&gt; fn)</code></li> <li><code>&lt;U&gt; CompletionStage&lt;U&gt; applyToEither(CompletionStage&lt;T&gt; other, Function&lt;T, U&gt; fn)</code></li> <li><code>&lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine(CompletionStage&lt;U&gt; other,BiFunction&lt;T,U,V&gt; fn)</code></li> <li><code>CompletionStage&lt;Void&gt; thenRun(Runnable action)</code></li> <li><code>CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action)</code></li> <li><code>CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action)</code></li> <li><code>CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</code></li> <li><code>CompletionStage&lt;Void&gt; acceptEither(CompletionStage&lt;T&gt; other, Consumer&lt;T&gt; action)</code></li> <li><code>&lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;U&gt; other,BiConsumer&lt;T,U&gt; action)</code></li> <li><code>&lt;U&gt; CompletionStage&lt;U&gt; thenCompose(Function&lt;T,CompletionStage&lt;U&gt;&gt; fn)</code></li> <li><code>CompletionStage&lt;T&gt; whenComplete(BiConsumer&lt;T, Throwable&gt; action)</code></li> <li><code>CompletionStage&lt;T&gt; exceptionally(Function&lt;Throwable, T&gt; fn)</code></li> <li><code>&lt;U&gt; CompletionStage&lt;U&gt; handle(BiFunction&lt;T, Throwable,U&gt; fn)</code></li></ul> <h5 id="completablefuture-t"><a href="#completablefuture-t" class="header-anchor">#</a> CompletableFuture&lt;T&gt;</h5> <p>同时实现了 Future&lt;T&gt; 、 CompletionStage&lt;T&gt; 两个接口，即实现了异步执行和结果访问两个功能。该类是 Java 实现“函数是编程”的关键。主要 API 如下：</p> <ul><li><code>CompletableFuture()</code> 构造一个处于未完成阶段的对象，没有实际意义</li> <li><code>static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)</code></li> <li><code>static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</code></li> <li><code>static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</code></li></ul> <h3 id="线程同步"><a href="#线程同步" class="header-anchor">#</a> 线程同步</h3> <h4 id="volatile"><a href="#volatile" class="header-anchor">#</a> volatile</h4> <blockquote><p>volatile 英文“易挥发的不稳定的”</p></blockquote> <ul><li>可见性：保证了变量在工作内存中被修改后，能立刻反应到主内存和其他工作内存中</li> <li>禁止指令重排：保证了变量在当前工作内存中被修改时，语义顺序前的指令都已完成，语义顺序后的指令还未开始执行（考虑到其他线程得知修改后，能够根据修改线程的语义逻辑作出正确的逻辑判断）</li></ul> <h4 id="synchronized"><a href="#synchronized" class="header-anchor">#</a> synchronized</h4> <p>JVM 没有把 lock 和 unlock 开放给字节码使用，但 JVM 开放了更高层次的指令 monitorenter 和 monitorexit ，反应到java代码中就是 synchronized 关键字。要想执行同步安全的代码段就先获取附属的同步监视器的锁定，否则将阻塞，直到获取锁定，执行过程中，其他线程会因无法获取锁定而被阻塞。</p> <ul><li><p>代码块同步</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token comment">// 同步监视器是 obj</span>
</code></pre></div></li> <li><p>方法同步</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> xxx <span class="token punctuation">{</span>
    xxx <span class="token keyword">synchronized</span> xxx <span class="token function">methodname</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token comment">// 同步监视器是 this</span>
</code></pre></div></li></ul> <p>Object 类提供了三个方法用于实现通信，前提是对象必须被当做同步监视器</p> <ul><li><code>void wait()</code> 放弃锁定，阻塞当前线程，等待直到被唤醒</li> <li><code>void wait(long time)</code> 可以自动唤醒</li> <li><code>void notify()</code> 随机唤醒一个在此同步监听器上等待的线程</li> <li><code>void notifyAll()</code> 唤醒所有在此同步监听器上等待的线程</li></ul> <h5 id="运行流程"><a href="#运行流程" class="header-anchor">#</a> 运行流程</h5> <p>随着 Java 版本的迭代，synchronized 的性能得到了充分的优化，底层经历了<strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong>三个阶段，同时进行了<strong>锁消除</strong>、<strong>锁粗化</strong>等优化手段。</p> <h4 id="cas"><a href="#cas" class="header-anchor">#</a> CAS</h4> <p>CAS 全名 Compare and Swap ，是一项乐观锁技术，也称为无锁技术。CAS 定义了一个原子性的操作：执行写入之前判断内存值与期望值是否相等，如果相等则执行写入，返回成功信号，如果不相等则放弃写入，返回失败信号。</p> <blockquote><p>这种无锁技术只能适用于一些资源竞争不激烈的情景，它可以避免加锁解锁带来的性能损耗；但是如果资源竞争过于激烈，可能出现多次尝试 CAS 都失败而带来的性能损耗。</p></blockquote> <blockquote><p>现如今很多 CPU 都支持 CAS 指令。</p></blockquote> <p>sun.misc.Unsafe 对象提供了对 CAS 的支持：</p> <ul><li><code>boolean compareAndSwapInt(Object o, long offset, int expected, int x)</code></li> <li><code>boolean compareAndSwapLong(Object o, long offset, long expected, long x)</code></li> <li><code>boolean compareAndSwapObject(Object o, long offset, Object expected, Object x)</code></li></ul> <blockquote><p>sun.misc.Unsafe 包装了 jdk.internal.misc.Unsafe 。</p></blockquote> <h5 id="varhandle"><a href="#varhandle" class="header-anchor">#</a> VarHandle</h5> <h5 id="atomic"><a href="#atomic" class="header-anchor">#</a> Atomic</h5> <p>Unsafe 类对于开发者不是很友好，java.util.concurrent.atomic 包提供了更友好的 API，并且增加了很多常用的原子操作方法以供开发者使用。</p> <p>AtomicInteger 是最常用的原子类，主要的 API 如下：</p> <ul><li><code>int addAndGet(int delta)</code></li> <li><code>int getAndAdd(int delta)</code></li> <li><code>int incrementAndGet()</code></li> <li><code>int getAndIncrement()</code></li></ul> <blockquote><p>除了 AtomicInteger ，该包下还支持了 boolean、long、对象引用、数组元素、对象字段等功能。</p></blockquote> <blockquote><p><strong>解决 CAS 操作的 ABA 问题</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">AtomicStampedReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicStampedReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">,</span>reference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>reference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></blockquote> <h4 id="aqs"><a href="#aqs" class="header-anchor">#</a> AQS</h4> <blockquote><p>协调多个线程运行状态的工具对象称为同步器。</p></blockquote> <p>AQS 全名 AbstractQueuedSynchronizer ，即抽象队列同步器，是一种同步器的实现框架类，可以实现阻塞锁和顶层的一些同步器。</p> <p>底层维护了一个 volatile 的 int 的变量 state ，需要重写以下 API 来改变 state ：</p> <ul><li><code>protected boolean tryAcquire(int arg)</code></li> <li><code>protected boolean tryRelease(int arg)</code></li> <li><code>protected int tryAcquireShared(int arg)</code></li> <li><code>protected boolean tryReleaseShared(int arg)</code></li> <li><code>protected boolean isHeldExclusively()</code></li></ul> <blockquote><p>AQS定义两种资源共享方式：Exclusive 和 Shared</p></blockquote> <p>外部通过以下 API 来访问 AQS 实现类：</p> <ul><li><code>final void acquire(int arg)</code></li> <li><code>final void acquireInterruptibly(int arg)</code></li> <li><code>final void acquireShared(int arg)</code></li> <li><code>final void acquireSharedInterruptibly(int arg)</code></li> <li><code>final boolean release(int arg)</code></li> <li><code>final boolean releaseShared(int arg)</code></li></ul> <h5 id="acquire-release-流程"><a href="#acquire-release-流程" class="header-anchor">#</a> acquire - release 流程</h5> <p><strong>acquire</strong></p> <ol><li>尝试获得锁，如果获得锁，直接返回</li> <li>否则，将当前线程包装成 Node 对象放入等待队列的尾部，激活自旋
<ol><li>如果前驱为 head 且尝试获得锁成功，删除旧 head ，设置自身为 head，停止自旋</li> <li>否则，阻塞当前线程，等待被唤醒，唤醒后重新自旋</li></ol></li> <li>线程中断自处理。</li></ol> <p><strong>release</strong></p> <ol><li>尝试释放锁，一般都会成功的</li> <li>唤醒 head 的后继 Node</li></ol> <h5 id="acquireshared-releaseshared-流程"><a href="#acquireshared-releaseshared-流程" class="header-anchor">#</a> acquireShared - releaseShared 流程</h5> <h4 id="lock"><a href="#lock" class="header-anchor">#</a> Lock</h4> <p>Lock 接口的方法提供了更加灵活的锁定操作：</p> <ul><li><code>void lock()</code></li> <li><code>void lockInterruptibly()</code> 可被中断</li> <li><code>boolean tryLock()</code></li> <li><code>boolean tryLock(long time, TimeUnit unit)</code> 可被中断</li> <li><code>void unlock()</code></li> <li><code>Condition newCondition()</code> 获取条件对象</li></ul> <p>用法如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token comment">//处理任务</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span><span class="token punctuation">{</span>
     
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//释放锁</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>指定时间长度或者不指定<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">try</span><span class="token punctuation">{</span>
         <span class="token comment">//处理任务</span>
     <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span><span class="token punctuation">{</span>
         
     <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//释放锁</span>
     <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//如果不能获取锁，则直接做其他事情</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code>lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果等待过程中当前线程被标记为“中断”，则会抛出异常，必须被捕获</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>  
 <span class="token comment">//.....</span>
<span class="token punctuation">}</span>
<span class="token keyword">finally</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="reentrantlock"><a href="#reentrantlock" class="header-anchor">#</a> ReentrantLock</h5> <p>ReentrantLock 实现了 Lock ，称为可重入锁，内部定义了一个非公平同步器和一个公平同步器，都继承自 AQS 。同步器内部维护了一个 state ，当获取锁时会判断当前线程是否持有锁，从而实现重入逻辑。</p> <blockquote><p>Lock 对象也是一种的同步器，实现类中借助了 AQS 的支持。</p></blockquote> <blockquote><p>可重入的意思是，获取锁的线程可以再次获取锁。</p></blockquote> <h5 id="readwritelock"><a href="#readwritelock" class="header-anchor">#</a> ReadWriteLock</h5> <p>ReadWriteLock 代表读写锁，API 如下：</p> <ul><li><code>Lock readLock()</code> 获取读锁</li> <li><code>Lock writeLock()</code> 获取写锁</li></ul> <h5 id="reentrantreadwritelock"><a href="#reentrantreadwritelock" class="header-anchor">#</a> ReentrantReadWriteLock</h5> <p>ReentrantReadWriteLock 实现了 ReadWriteLock ，称为可重入读写锁，内部也是定义了一个非公平同步器和一个公平同步器，都继承自 AQS 。此外还定义了一个读锁和一个写锁，这两个锁将共享宿主对象的同步器，巧妙的是，同步器里维护的 state 整型变量一分为二，分别由读锁和写锁维护。</p> <p><img src="/assets/img/image-20191210175611043.704d36e7.png" alt="image-20191210175611043"></p> <p>当获得锁时，会通过复合变量 state 实现读写锁之间的制约关系。</p> <table><thead><tr><th>当前锁状态</th> <th>读锁请求</th> <th>写锁请求</th></tr></thead> <tbody><tr><td>无锁</td> <td>可以</td> <td>可以</td></tr> <tr><td>读锁</td> <td>可以（可重入）</td> <td>阻塞（不可重入）</td></tr> <tr><td>写锁</td> <td>阻塞（可重入）</td> <td>阻塞（可重入）</td></tr></tbody></table> <h5 id="condition"><a href="#condition" class="header-anchor">#</a> Condition</h5> <p>通过Lock实例的 <code>newCondition()</code> 方法，获取对应的Condition实例，该接口有如下方法：</p> <ul><li><code>void await()</code></li> <li><code>await</code>的其他变体，功能丰富</li> <li><code>void signal()</code></li> <li><code>void signalAll()</code></li></ul> <p>该接口的实现类一般为 AQS 的内部类 ConditionObject 。</p> <blockquote><p>监视器同时承担了锁和线程通信两个功能，而同步锁只负责锁功能，线程通信则交给 Condition 对象来负责，这样，一个同步锁可以产生多个 Condition 对象，且多个 Condition 对象只负责自己的等待线程，不会相互影响。</p></blockquote> <h5 id="locksupport"><a href="#locksupport" class="header-anchor">#</a> LockSupport</h5> <h4 id="同步器"><a href="#同步器" class="header-anchor">#</a> 同步器</h4> <h5 id="countdownlatch"><a href="#countdownlatch" class="header-anchor">#</a> CountDownLatch</h5> <p>称为倒计时门栓，这种同步器可以实现：在一个或多个线程中等待其他线程完成一定数量的操作后继续执行。</p> <ul><li><code>CountDownLatch(int count)</code> count 表示倒计时总数</li> <li><code>void await()</code> 等待至倒计时为零，或被中断</li> <li><code>void countDown()</code> 倒计时减一</li></ul> <p>内部定义了一个同步器继承自 AQS ，倒计时就是 state 变量，每当调用 countDown 时，释放一次锁，state 减一，当调用 await 方法时，获取锁，如果 state 为零则获取成功，否则进入队列等待。</p> <h5 id="cyclicbarrier"><a href="#cyclicbarrier" class="header-anchor">#</a> CyclicBarrier</h5> <p>称为栅栏，这种同步器可以实现：让多个线程彼此等待，直到等待的线程达到一定数量后继续执行。</p> <ul><li><code>CyclicBarrier(int parties)</code></li> <li><code>CyclicBarrier(int parties, Runnable barrierAction)</code> 定义栅栏任务</li> <li><code>int await()</code></li> <li><code>void reset()</code> 重置</li></ul> <p>内部维护了一个 ReentrantLock 对象 lock 和一个锁对象的 Condition 对象 trip ，原理就是通过在 trip 上等待栅点实现的。因为考虑到了重置，所以内部还维护了一个 Generation 对象，其中的 broken 表示当前代是否被破坏，当调用 reset 时，将设置当前代的 broken ，每一个被唤醒的线程都会抛出 BrokenBarrierException。</p> <h5 id="semaphore"><a href="#semaphore" class="header-anchor">#</a> Semaphore</h5> <p>称为信号量，这种同步器可以实现：指定一定数量的“许可证”，线程可以获取许可和释放许可，如果没有空闲的许可证，则阻塞当前线程至获得许可证。</p> <ul><li><code>Semaphore(int permits)</code></li> <li><code>Semaphore(int permits, boolean fair)</code></li> <li><code>void acquire()</code></li> <li><code>void release()</code></li></ul> <p>内部定义了一个非公平同步器和一个公平同步器，都继承自 AQS 。</p> <h5 id="exchanger"><a href="#exchanger" class="header-anchor">#</a> Exchanger</h5> <h5 id="blockingqueue"><a href="#blockingqueue" class="header-anchor">#</a> BlockingQueue</h5> <p>当生产者线程试图向满的队列中添加元素，会被阻塞，直到不满的时候自动被唤醒；当消费者线程从空大队列中取出元素时，会被阻塞，直到不空的时候自动被唤醒。</p> <p>常用的接口实现有 ArrayBlockingQueue、LinkedBlockingQueue ...</p> <blockquote><p>LinkedTransferQueue 在 LinkedBlockingQueue 的基础上添加了两个方法：</p> <ul><li>transfer：如果已有消费者等待，则直接传递并返回，否则，入队，并等待至元素被消费</li> <li>tryTransfer：如果已有消费者等待，则直接传递并返回 true，否则，不入队并返回 false</li></ul></blockquote> <h3 id="线程安全"><a href="#线程安全" class="header-anchor">#</a> 线程安全</h3> <h4 id="线程安全的级别"><a href="#线程安全的级别" class="header-anchor">#</a> 线程安全的级别</h4> <ol><li>不可变：对于不可变类对象的访问一定是线程安全的</li> <li>绝对安全：对一个对象的访问不需要额外的同步措施</li> <li>相对安全：对一个对象的单次访问不需要额外的同步措施</li> <li>线程兼容：对一个对象的单次访问需要额外的同步措施</li> <li>线程对立：即使提供额外的同步措施也无法保证对象的正确访问</li></ol> <h4 id="stringbuffer"><a href="#stringbuffer" class="header-anchor">#</a> StringBuffer</h4> <h4 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> ConcurrentHashMap</h4> <p>1.7 版本时，采用分段锁保证线程安全，数据结构为“分段锁+数组+链表”；1.8 版本时，采用 synchronized+CAS 保证线程安全，数据结构为“数组+链表/红黑树”。</p> <p>官方没有提供 ConcurrentHashSet 类，需要通过 ConcurrentHashMap 对象的如下方法得到对应的 Set 对象</p> <ul><li><code>Set&lt;K&gt; newKeySet()</code> 返回键集，不能添加集元素</li> <li><code>Set&lt;K&gt; keySet(V v)</code> 参数是默认键值，将返回键集，可以添加集元素</li></ul> <p>或者调用 <code>Collections.newSetFromMap(concurrentHashMapObj)</code> 得到对应的 Set 对象</p> <h4 id="concurrentskiplistmap-与-concurrentskiplistset"><a href="#concurrentskiplistmap-与-concurrentskiplistset" class="header-anchor">#</a> ConcurrentSkipListMap 与 ConcurrentSkipListSet</h4> <h4 id="concurrentlinkedqueue-与-concurrentlinkeddeque"><a href="#concurrentlinkedqueue-与-concurrentlinkeddeque" class="header-anchor">#</a> ConcurrentLinkedQueue 与 ConcurrentLinkedDeque</h4> <h4 id="copyonwritearraylist-与-copyonwritearrayset"><a href="#copyonwritearraylist-与-copyonwritearrayset" class="header-anchor">#</a> CopyOnWriteArrayList 与 CopyOnWriteArraySet</h4> <h2 id="反射编程"><a href="#反射编程" class="header-anchor">#</a> 反射编程</h2></div></div><div class="box"><div class="post-tags"><span class="post-tag ca-tag"><span><a class="firstca" style="color: white">程序设计</a><span><svg aria-hidden="true" focusable="false" data-prefix="fa" data-icon="caret-right" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512" class="svg-inline--fa fa-caret-right fa-w-6" style="width:1rem;"><path fill="currentColor" d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"></path></svg></span></span><span><a class="endcd" style="color: white">Java</a><!----></span></span><a class="ta-tag post-tag">java</a><span class="da-tag post-tag">2020.09.25</span><!----></div></div><div class="box"><div id="vcomments"></div></div></div></div></div></div></main><div id="top-btn" class="btn" style="display:none;"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="arrow-up" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-arrow-up fa-w-14 fa-lg"><path fill="currentColor" d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"></path></svg></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2d05b873.js" defer></script><script src="/assets/js/9.fd2d7f08.js" defer></script><script src="/assets/js/3.5fc63a44.js" defer></script><script src="/assets/js/11.afdccb1f.js" defer></script>
  </body>
</html>
